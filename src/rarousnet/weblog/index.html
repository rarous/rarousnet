<!doctype html>
<html lang="cs">
<head prefix="og: http://ogp.me/ns# fb: http://ogp.me/ns/fb#">
<meta charset="utf-8">
<title>rarouš.weblog</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="Aleš Roubíček píše o webdesignu a dotnetu.">
<meta name="blogcatalog" content="9BC9064972">
<link rel="alternate" type="application/rss+xml" href="http://feeds.feedburner.com/rarous-weblog" title="rarouš.weblog - poslední články">
<link rel="alternate" type="application/rss+xml" href="http://feeds.feedburner.com/rarous/weblog/comments" title="rarouš.weblog - komentáře k článkům">
<link rel="canonical" href="http://www.rarous.net/weblog/">
<meta property="fb:app_id" content="215763288621854">
<meta property="og:type" content="website">
<meta property="og:url" content="http://www.rarous.net/weblog/">
<meta property="og:title" content="rarouš.weblog">
<meta property="og:locale" content="cs_CZ">
<!--[if lt IE 9]><script src=http://html5shim.googlecode.com/svn/trunk/html5.js></script><![endif]-->
<link rel="stylesheet" href="/design/blog/blog.css?30">
<link rel="stylesheet" href="/assets/css/prism.css">
<link rel="shortcut icon" href="/design/blog/favicon.png" type="image/png">
<script>
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');
ga('create', 'UA-90726-1', 'auto');
ga('send', 'pageview');
</script>
</head>
<body id="rarous">
    <div id="top">

        <div class="wai">
            <a href="http://www.ippi.cz/klavesove-zkratky/neni-mapa-stranek.html" accesskey="1" tabindex="1">Klávesové zkratky na tomto webu - rozšířené</a>
            <a href="#content" accesskey="0" tabindex="2">Na obsah stránky</a>
        </div>

        <div id="head">
            <h1><a href="/weblog/" title="Přejít na weblog">rarouš.weblog<span class="image"></span></a></h1>
            <div class="menu" role="menu">
                <a href="/" accesskey="2">Home</a>
                <a href="/photos/" accesskey="5">Photos</a>
                <a href="/#contact" accesskey="6">Contact</a>
                <strong>Blog</strong>
                <a href="/webdesign/" accesskey="7">Projects</a></div>
        </div>

<div id="content">

<article class="hentry" id="article-454">
<header>
<h2 class="entry-title"><a href="http://www.rarous.net/weblog/454-legacy-code-writer-part-2.aspx" title="Legacy code writer - part 2" rel="Bookmark">Legacy code writer - part 2</a></h2>
<p class="info">
<span class="published">11.27 - 2. června 2013<span class="value" title="2013-06-02T11:27:45Z"></span></span> |
<strong>Moje práce</strong>
</header>
<div class="entry-content">

<p>Dostal jsi nový úkol, implementovat jednoduchou featuru do korporátního
projektu. Jenže ten kód byl past vedle pasti.

<p>Produkoval jsi legacy kód, kvůli <em>Legacy code writerovi</em>.

<h3 id="toc-nikdo-nepise-legacy-code-od-zakladu">Nikdo nepíše legacy code od
základu</h3>

<p>Je dost možný, že vám <a
href="http://www.rarous.net/weblog/453-legacy-code-writer-part-1.aspx">první
díl</a> zněl trochu povědomně. Každý z nás se dost pravděpodobně
v podobné situaci ocitl.

<p>Nyní, prosím, zkuste přehodnotit svou víru ve zlého <em>Legacy code
writera</em>. Myslíte si, že opravdu existuje? Jste si jistí, že pokaždé
když narazíte na legacy code, tak k němu existuje mystický můž, který to
celé napsal od základu?

<p>Víte čemu věřím já? Že tento muž vůbec neexistuje, že je to jen
velice příjemná a pohodlná zástěrka. Není tu žádná taková osoba,
která by byla zodpovědná za celej ten bordel. Špatný programátor, Legacy
code writer, je jen fiktivní postavou vytvořenou k tomu, aby nám pomohl
obhájit naše malé, přetrvávající, hříchy.

<p>Došel jsem k názoru, že <strong>psaní legacy code je distribuovanou
aktivitou</strong>. Každý z nás do tohoto vleklého procesu, třeba
i nevědomky, přispívá.

<p>Zbytečně nezahazujte čas pátráním, kdo za to může, protože to
<strong>my všichni</strong>. Každý z nás!

<h3 id="toc-legacy-code-je-jako-prach">Legacy code je jako prach</h3>

<p>Pokud neuklízíte, neustále se usazuje a je jedno jestli se díváte
nebo ne.

<p>Každý kus kódu, pokud je spravován více lidmi, tíhne k tomu stávat se
špagetami nebo lasagněmi. Entropie má potřebu růst. Je to absolutně
přirozený proces.

<p>Nevěříte?

<p>Zkuste se na to podívat z jiného úhlu pohledu: <strong>Kód přirozeně
netíhne k tomu být čím dál tím lepší pouhým přidáváním featur
hordou programátorů.</strong>

<p>Mně to zní jako jednoduchý přírodní zákon: <strong>Živý kód tíhne
k tomu, stávat se horším, dokud nedojde k záměrnému aplikování síly
proti přirozené potřebě entropie růst.</strong>

<p>Legacy code je to, co získáte, pokud nejste odhodlaný přísně aplikovat
dobré zásady při správě kódu.

<h3 id="toc-dve-spatna-rozhodnuti-se-vzajemne-nekompenzuji-komuluji">Dvě
špatná rozhodnutí se vzájemně nekompenzují. Komulují!</h3>

<p>První verze byla pravděpodobně navržená dobře. Šlo to celkem snadno,
před programátorem byl list nepopsaného papíru. :)

<blockquote>
	<p>Každý dokáže navrhout dobrý kód na zelený louce a udržovat ho po dobu
	tří měsíců. Pouze profesionální vývojář to zvládne i po dobu
	následujících let.
</blockquote>

<p>Nekritizujte prvního progrmátora, on možná odvedl velmi slušnou práci.
Jenže jak na chvilku polevíte, začnou se objevovat první nepatrné
částečky legacy kódu. Problém s částečkama legacy kódu je jako
s korálama: mají potřebu se na sebe lepit až z nich nakonec vznikne
nepropustná bariera pevná jako skála, se kterou už nepohnete.

<p>Zaveďte <strong>dočasnou proměnnou</strong> a vězte, že další
programátor se bude cítit oprávněn na ní nalepit nějakou funkcionalitu.
Udělejte <strong>copy&amp;paste</strong> maličké pětiřádkové
funkcionality a čekejte že vaše budoucí já v jedné z těch kopií
změní dva řádky a připraví tak jeho nástupce, kteří se to pokusí
refactorvat, o několik vlasů. Nejspíš to vzdají.

<p><strong>Vynechte unit test</strong> a vězte, že další team si
pomyslí:

<blockquote>
	<p>Předchozí programátor si myslel, že pokrýt tuhle funkcionalitu testy je
	příliš nákladné. No, teď to určitě nebude o nic snažší. Takže se na
	to taky vyprdneme.
</blockquote>

<p>A tady to začne chátrat. Taky se tomu taky říká <a
href="http://cs.wikipedia.org/wiki/Teorie_rozbit%C3%A9ho_okna">teorie rozbitého
okna</a>…

<!-- by Texy2! -->
</div>
<footer class=vcard>
Autor: <strong class="user fn">Aleš Roubíček</strong> |
<a href="http://www.rarous.net/weblog/454-legacy-code-writer-part-2.aspx#komentare">12x komentováno</a>
</footer>
</article>

<article class="hentry" id="article-453">
<header>
<h2 class="entry-title"><a href="http://www.rarous.net/weblog/453-legacy-code-writer-part-1.aspx" title="Legacy code writer - part 1" rel="Bookmark">Legacy code writer - part 1</a></h2>
<p class="info">
<span class="published">18.50 - 1. června 2013<span class="value" title="2013-06-01T18:50:30Z"></span></span> |
<strong>Moje práce</strong>
</header>
<div class="entry-content">

<p>Dostal jsi nový úkol. Zadání zní jasně:

<blockquote>
	<p>Přidat jednoduchou featuru do korporátního projektu.
</blockquote>

<p>Sice o tom nic nevíš, ale požadavky zní rozumně a jednoduše. To přece
zvládneš.

<p>Nebo si to aspoň myslíš. Dokud neotevřeš ty zpropadený zdrojáky.

<p>Nehoráznej bordel. Který prase tohle mohlo napsat? Na monitoru vidíš jen
změť špaget a lasagní. Ach. Vypadá to, jako by někdo záměrně vytvořil
sbírku všech známých anti-patternů.

<p>Vztek roste, pomalu začínáš nenávidět toho, kdo tohle zvěrstvo
způsobil. Tahle hromada sraček ti nedovoluje pracovat tak, jak ti tvé
svědomí káže a jak bys opravdu chtěl. Chceš přece dělat dobrý řemeslo,
držet se oblíbených vzorů. Sám sobě jsi slíbil, že budeš psát kód
s vysokou kohezí, volnými vazbami a ty sám nejlíp víš s čim…
<strong>Ale zkrátka to není možný.</strong>

<p>Jak taky? Ten neschopnej blbec všude používá <strong>globální
proměnné</strong>, skoro všechno je <strong>statický</strong>, <strong>kód
se na mnoha místech opakuje</strong> a navíc <strong>nikde žádný
testy</strong>!

<p>A hele, tady dokonce používá magický konstanty!

<pre><code class="language-csharp">int HRW_UND = 12;</code></pre>

<p>Co sakra může ta dvanáctka znamenat? A co je to <code>HRW_UND</code>?
Uff. Ať schoří v pekle, ten bastard!

<p>Tak. Nemáš moc času, deadline se neúprosně blíží a tys měl přece
jen přidat jednoduchou featuru a ne refactorovat celé to boží dopuštění.
To přece není tvoje práce! Ne asi.

<h3 id="toc-legacy-kod-vzdycky-vyhraje-nad-cistym-kodem">Legacy kód vždycky
vyhraje nad čistým kódem</h3>

<p>Tak jo, ten dobrák, co udělal tuhle spoušť vyhrál. Přidáš tam tu
featuru bez striktního dodržování svých zásad. Proč ne? Vždyť ty za
tenhle bordel přece nemůžeš, tys ho neudělal, musíš akorát dokončit
svůj úkol. O to tu jde.

<p>Byl jsi donucenej dělat pod svoje možnosti. Ale není to tvoje chyba. Máš
dobré důvody, vždyť je to přece chyba autora legacy kódu.

<p>Tady bys chtěl předat závislost pomocí <strong>dependency
injection</strong>, ale úsilí překopat celou tuhle šílenou věc by
několikrát překročilo rámec tvé featury. Všechno je statický, nikde
žádná rozhraní, brutální dědičnost a spousta výskytů operátoru
<code>new</code>… Nemáš čas a ta šílená code base ti vůbec nepomáhá.
<em>Srát na Inversion of Control</em>!

<p>Radši přidáš statickou metodu do service locatoru. Sice nenávidíš
service locator, ale je prolezlej úplně všude a nejde se ho lehce zbavit.

<p>A tady je zas metoda, která řeší dvě různý věci najednou. Ty bys
potřeboval jen jednu, ale celý je to tak propletený. Je to pěkně těžký
oddělit tyhle dvě různý věci od sebe, protože ta třída ani nejde
otestovat. Nakonec radši zkopíruješ tu část kódu, kterou potřebuješ a
vložíš ji tam, kde se ti bude hodit.

<p>Hej! A co tahle 50 řádková metoda s 18 <code>if</code>ama? Proč ten
vůl nepoužil strategii? Refactorovat celý to zvěrstvo, nebo přidat 19.
<code>if</code>? :) Tak určitě! Ať původní autor shoří v pekle!

<p>Konečně. Teď ještě potřebuješ konfigurační parametr. Normálně bys
to poslal přes property injection, ale původní autor použil <code>HRW_UND =
12</code>, tak tam prdneš <code>HRW_UND = 98</code>.

<p><strong>Je to jeho vina.</strong>

<!-- by Texy2! -->
</div>
<footer class=vcard>
Autor: <strong class="user fn">Aleš Roubíček</strong> |
<a href="http://www.rarous.net/weblog/453-legacy-code-writer-part-1.aspx#komentare">6x komentováno</a>
</footer>
</article>

<article class="hentry" id="article-451">
<header>
<h2 class="entry-title"><a href="http://www.rarous.net/weblog/451-jak-teda-s-tema-vyjimkama-v-busines-logice.aspx" title="Jak teda s těma výjimkama v busines logice?" rel="Bookmark">Jak teda s těma výjimkama v busines logice?</a></h2>
<p class="info">
<span class="published">14.11 - 17. května 2013<span class="value" title="2013-05-17T14:11:33Z"></span></span> |
<strong>Moje práce</strong>
</header>
<div class="entry-content">

<p>Na develu se rozvíjí debaty o tom, zda je zpátečnické odrazovat od
vyhazování výjimek. Já patřím mezi zpátečníky. :) Tady je moje
odpovědˇ, kterou je IMO škoda nemít veřejně dostupnou, takže ji publikuju
i tady na blogu.

<p>Na začátek je dobré se opřít o nějakou autoritu, proto tady pro
začátek ocituju <a
href="http://blogs.msdn.com/b/kcwalina/archive/2005/03/16/396787.aspx">.net
Framework Design Guidelines doporučení k výjimkám</a>:

<ol>
	<li>Nevracejte chybové kódy. K tomuto účelu jsou určeny výjimky.

	<li>Vyhazujte výjimky pokud dojde k běhové chybě. Pokud člen nemůže
	úspěšně provést úkol za nějž nese zodpovědnost, mělo by to být
	považováno za běhovou chybu a měla by být vyhozena výjimka.

	<li>Pokud se dostanete do stavu, kterému nepomůže žádné ošetření
	výjimky, proveďtě ukončení procesu pomocí
	<code>Environment.Fa­ilFast()</code>.

	<li>Nepoužívejte výjimky k formálnímu řízení toku programu.
	S výjimkou systémových selhání by vždy měl existovat způsob jak se
	vyhnout vyhazování výjimek.

	<li>Zvažte důsledky vyhozené výjimky na výkon.

	<li>Vždy zdokumentujte všechny výjimky vyhazované veřejnými členy
	z důvodu porušení jejich kontraktu.

	<li>Nemějte veřejné členy, které mají nebo nemají vyhazovat výjimky na
	základě nějakého parametru. <code>Type GetType(string name, bool
	throwOnError)</code>

	<li>Nemějte veřejné členy které vracejí výjimku jako návratovou hodnotu
	nebo out parametr.

	<li>Nastavte všechny relevatní vlastnoti vyhazované výjimky.

	<li>Preferujte užití systémových výjimek před vlastními.

	<li>Vlastní výjimky vyhazujte v případě, že vyžadují odlišný způsob
	ošetření než existující typy výjimek.

	<li>Nikdy nevytvářejte vlastní typ výjimky, jen proto, aby váš team měl
	nějakou vlastní výjimku.

	<li>Vyhazujte co nejkonkrétnější výjimky.

	<li>Nevracejte chybové kódy z obav o výkonostní dopady při vyhazování
	výjimek.

	<li>Používejte vzory jako TryParse, které snižují negativní dopady na
	výkon způsobené vyhazováním výjimek.
</ol>

<p>Z texu je zřejmé, že vyhazování výjimek má své opodstatnění.
Důležité je však v jakých scénářích se výjimky vyhazovat mají a
v jakých ne.

<p>Často se tu objevují příklady s validací vstupních hodnot nebo třeba
autentikace uživatele. Začněme validátorem:

<p>Primární zodpovědností validátoru je validovat hodnoty. Je nevalidní
hodnota příčinou nemožnosti korektní práce validátoru (důvodem
k vyhození výjimky)? Není (viz bod <code>2</code>). Můžeme to řešit
vracením primitivy jako je <code>bool</code>. Já si však myslím, že taková
hodnota je nedostatečná. Potřebujeme výsledek validace zpropagovat někam,
kde se s ním bude dále pracovat. Vyhodíme tedy výjimku a tu pak odchytíme?
Tím se ale dostáváme k bodu <code>4</code>. Lepším řešením je definovat
komplexní návratový typ:

<pre><code class="language-fsharp">type ValidationResult =
  | Valid
  | Invalid of ValidationError list</code></pre>

<p>Pokračujme s autentikací uživatele. Běžnou praxí je vyhazování
<code>SecurityException</code> pokud se nepovede uživatele autentikovat.
Výjimka se pak nechá probublat do UI vrstvy, kde se ošetří a uživateli se
zobrazí hláška, že zadal špatné jméno nebo heslo. Opět však jde
o porušení 4. bodu. Autentikace tam může vracet opět <code>bool</code>
nebo rovnou instanci <code>User</code> a v případě nevydařené autentikace
<code>null</code>. Tím se zbavíme bezpečnostních výjimek, ale zase si
zavedeme potenciální chybu v podobě <code
title="NullReferenceException">NRE</code>… Proto si opět myslím, že by se
měl vracet adekvátní typ:

<pre><code class="language-fsharp">type AuthenticationResult =
  | NotAuthenticated
  | Authenticated of User</code></pre>

<p>Autentikační modul samozřejmě může vyhazovat výjimky, ale většinou
budou spojené s nefungující infrastrukturou (LDAP, SQL nebo jinej auth
provider), to je totiž validní důvod, proč nemůže autentikace
doběhnout.

<!-- by Texy2! -->
</div>
<footer class=vcard>
Autor: <strong class="user fn">Aleš Roubíček</strong> |
<a href="http://www.rarous.net/weblog/451-jak-teda-s-tema-vyjimkama-v-busines-logice.aspx#komentare">Zatím bez komentáře</a>
</footer>
</article>

<article class="hentry" id="article-450">
<header>
<h2 class="entry-title"><a href="http://www.rarous.net/weblog/450-jak-rozbehat-bower-ve-visual-studiu.aspx" title="Jak rozběhat Bower ve Visual Studiu" rel="Bookmark">Jak rozběhat Bower ve Visual Studiu</a></h2>
<p class="info">
<span class="published">13.13 - 3. května 2013<span class="value" title="2013-05-03T13:13:41Z"></span></span> |
<strong>Moje práce</strong>
</header>
<div class="entry-content">

<p>Takový malý tutoriálek pro command line junkies, jak si rozběhat <a
href="https://github.com/bower/bower">bower</a> ve Visual Studiu.

<p>Nainstalujte si Chockolatey:

<pre class="console"><code>@powershell -NoProfile -ExecutionPolicy unrestricted -Command "iex ((new-object net.webclient).DownloadString('https://chocolatey.org/install.ps1'))" &amp;&amp; SET PATH=%PATH%;%systemdrive%\chocolatey\bin</code></pre>

<p><em>(<code>Win+R</code>, <code>Ctrl+V</code>, <code>Enter</code>)</em>

<p>Nainstalujte si Node:

<pre class="console"><code>cinst nodejs.install</code></pre>

<p>Vytvořte si profil pro nuget konzoli
<code>%UserProfile%\Documents\WindowsPowerShell\NuGet_profile.ps1</code> a do
něj přidejte:

<pre class="console"><code>Set-Alias npm "C:\Program Files\nodejs\npm.cmd"
Set-Alias bower "~\AppData\Roaming\npm\bower.cmd"</code></pre>

<p>Spusťte si Visual Studio, otevřete Package Management Consoli a
napište:

<pre class="console"><code>npm install -g bower</code></pre>

<p>A jedem. :)

<!-- by Texy2! -->
</div>
<footer class=vcard>
Autor: <strong class="user fn">Aleš Roubíček</strong> |
<a href="http://www.rarous.net/weblog/450-jak-rozbehat-bower-ve-visual-studiu.aspx#komentare">Zatím bez komentáře</a>
</footer>
</article>

<article class="hentry" id="article-449">
<header>
<h2 class="entry-title"><a href="http://www.rarous.net/weblog/449-parsovani-primitivnich-typu-znova-a-lepe.aspx" title="Parsování primitivních typů znova a lépe" rel="Bookmark">Parsování primitivních typů znova a lépe</a></h2>
<p class="info">
<span class="published">17.10 - 23. dubna 2013<span class="value" title="2013-04-23T17:10:57Z"></span></span> |
<strong>Moje práce</strong>
</header>
<div class="entry-content">

<p>Způsobů, jak parsovat primitivní typy z texu, je celá řada. Každý typ
má svou statickou metodu <code>Parse</code>, která vyhodí výjimku, když se
jí to nepovede. Pak tu máme modul <code>Convert</code>, který dokáže
parsovat poměrně bezpečně, ale ne vždy chceme dostávat
<code>default</code> hodnoty, když se mu podstrčí nic.

<p>Občas zkrátka potřebujeme mít absenci nějaké hodnoty vyjádřenou
v logice kódu. Proto často nezbývá než se vrhnout po hlavě do šíleného
vzoru, který je v <acronym title="Base Class Library">BCL</acronym>
rozšířen jak mor v době temna – <code>TryParse</code>. Protože tyto
metody vznikly někdy v době, kdy si ještě mohlo <acronym
title="Common Language Runtime">CLR</acronym> o generikách nechat zdát, je
práce s ní celkem neohrabaná a plná nepěkných věcí, jako
<code>out</code> parametry nebo porušení základního objektového principu
<em>tell don't ask</em>.

<pre><code class="language-csharp">int? TryParse(string input) {
  int result;
  if (Int32.TryParse(input, out result)) return result;
  return null;
}</code></pre>

<p>Tohle je jednoduchá ukázka, kterou jistě ve svém kódu najdete
nespočetněkrát. Proč už něco takovýho není v BCL od verze 2?
Každopádně má to své mouchy, třeba teď to pro změnu <a
href="/weblog/447-zatocime-s-null.aspx">vrací null</a>! A to jsme jeden
problém vyřešili zavedením jiného.

<p>Tak se necháme inspirovat u F#, které nemá podporu pro <code>out</code>
parametry. Ten to řeší nějak tak:

<pre><code class="language-csharp">Tuple&lt;bool, int&gt; TryParse(string input) {
  int result;
  bool success = Int32.TryParse(input, out result);
  return Tuple.Create(success, result);
}</code></pre>

<p>Bohužel C# není jazyk, který by prvotřídně podporoval
<code>Tuple</code>s. Můžeme se ptát proč, ale je to asi taky zbytečný.
Každopádně, nemáme problém s <code>null</code>, ale typ samotný nám toho
taky moc neřekne. Co je ten <code>bool</code>? Nevíme, dokud se nepodíváme
do dokumentace – kódu. Musí to jít i lépe! Maybe. ;)

<pre><code class="language-csharp">Maybe&lt;int&gt; TryParse(string input) {
  int result;
  bool success = Int32.TryParse(input, out result);
  return success ? result.ToMaybe() : new Nothing&lt;int&gt;();
}</code></pre>

<p>Nyní máme existenci hodnoty vyjádřenou na úrovni typu a můžeme s ní
bezpečně pracovat. Můžeme využít funkcionální kompozice, a hodnotu,
pokud existuje, dále zpracovávat. Nikde (skoro), však nemusíme ověřovat,
jestli ji máme nebo ne. Kód se tak krásně vyčistí.

<p>Celé řešení můžeme nakonec pěkně generalizovat a vytvořit si
vlastní modul pro parsování:

<pre><code class="language-csharp">public static class ParseEx {
  public delegate bool ParserDelegate&lt;T&gt;(string input, out T result);

  public static Maybe&lt;T&gt; Parse&lt;T&gt;(string input, ParserDelegate&lt;T&gt; parser) {
    T result;
    bool isSuccess = parser(input, out result);
    return isSuccess ? result.ToMaybe() : new Nothing&lt;T&gt;();
  }

  public static Maybe&lt;DateTime&gt; ParseDateTime(string input) {
    return Parse&lt;DateTime&gt;(input, DateTime.TryParse);
  }

  public static Maybe&lt;int&gt; ParseInt32(string input) {
    return Parse&lt;int&gt;(input, Int32.TryParse);
  }
}</code></pre>

<p>Máme jednu parametricky polymorfní metodu, která nám umožňuje parsovat
libovolná data, pomocí předaného delegáta. Tu pak používáme
k vytvoření specifických parsovacích metod, které nám umožní opět kód
pročistit.

<p>Kdybyste hledali implementaci <code>Maybe</code>, <a
href="https://gist.github.com/rarous/5355792">najdete ji v tomhle gistu</a>
i se spoustou šikovných extenzí.

<p>Toto řešení může mít u některých performance hunterů některé
efekty, ze kterých by nemuseli klidně spát. Hlavně ty alokace na heapu,
když jsme mohli zůstat v klidu na zásobníku. No jo. V tohle případě je
však zisk z čitelnosti a korektnosti o tolik řádů větší než pár
ušetřených cyklů levného výpočetního výkonu, že to snad ani nemá cenu
zase v komentářích řešit, co? ;)

<!-- by Texy2! -->
</div>
<footer class=vcard>
Autor: <strong class="user fn">Aleš Roubíček</strong> |
<a href="http://www.rarous.net/weblog/449-parsovani-primitivnich-typu-znova-a-lepe.aspx#komentare">Zatím bez komentáře</a>
</footer>
</article>

<article class="hentry" id="article-448">
<header>
<h2 class="entry-title"><a href="http://www.rarous.net/weblog/448-deset-duvodu-proc-nepouzivat-funkcionalni-jazyky.aspx" title="Deset důvodů proč nepoužívat funkcionální jazyky" rel="Bookmark">Deset důvodů proč nepoužívat funkcionální jazyky</a></h2>
<p class="info">
<span class="published">10.15 - 14. dubna 2013<span class="value" title="2013-04-14T10:15:12Z"></span></span> |
<strong>Moje práce</strong>
</header>
<div class="entry-content">

<p>Máte už plný zuby toho šílenýho povyku okolo funkcionálních jazyků?
Já teda jo. Myslím, že je načase sepsat pár rozumných důvodů, proč se
od něho držet dál. <strong>Funkcionální programování není pro
každého.</strong> To je důležité zmínit hned na začátku.

<p>Pro jistotu, když píšu „staticky typovaný funkcionální jazyk,“ mám
na mysli jazyk, který i dokáže odvozovat typy, jeho datové struktury
nepodporují mutace, a podobné nesmysly. V praxi to znamená, že myslím
zcela nepraktické (akademické) jazyky jako je Haskell nebo jazyky z rodiny ML
(jako OCaml nebo F#).

<h3 id="toc-duvod-prvni-nemam-zajem-sledovat-posledni-vystrelky">Důvod první:
Nemám zájem sledovat poslední výstřelky</h3>

<p>Jako většina programátorů, jsem přirozeně konzervativní a nerad se
učím nové věci. To je také důvod proč jsem si vybral kariéru v IT.

<p>Rozhodně nejančím z každé žhavé novinky, jen proto, že všichni
frajeři se z ním můžou podělat. Já si radši počkám, až ten
výstřelek trochu dospěje a ukáže se trochu perspektivním. Pro mě tu není
funkcionální programování dostatečně dlouho, aby mě přesvědčilo, že
tu s námi ještě nějakou dobu bude.

<p>Ano, někteří se nás mohou snažit přesvědčovat, že ML nebo Haskell tu
byly asi tak stejně dlouho jako naše staré známé oblíbené jazyky, jako je
Java nebo PHP, ale já o Haskellu, slyšel poprvé celkem nedávno, takže
s tímhle argumentem na mě nechoďte.

<p>A podívejte na to batole, F#. Vždyť je teprve sedm let starý! Jistě, to
může být dost dlouhá doba pro geology, ale na internetu? Sedm let!? To je
skoro okamžik.

<p>Tak, jak říkám, radši budu opatrný a ještě si pár dekád počkám,
jestli tu ještě tohle to funkcionální programování bude, nebo jestli se to
nakonec neukáže jako výstřelek doby.

<h3 id="toc-duvod-druhy-jsem-placen-od-radky-kodu">Důvod druhý: Jsem placen od
řádky kódu</h3>

<p>Já teda nevím jak vy, ale čím víc řádek napíšu, tím víc se cítím
produktivní. Pokud můžu za den vychrlit 500 řádků kódu, mám ze sebe
dobrý pocit. To byla dobře odvedená práce. Moje commity jsou velké a můj
šéf může jasně vidět, že jsem byl opravdu vytíženej.

<p>Když porovnám kód napsaný ve funkcionálním jazyce s kódem ve starém
dobrém céčkovém jazyce, chybí tam tolik kódu, že mě to až děsí.

<p>No, podívejte se sami na kód napsaný v povědomém jazyce:

<pre><code class="language-csharp">public static class SumOfSquaresHelper
{
   public static int Square(int i)
   {
      return i * i;
   }

   public static int SumOfSquares(int n)
   {
      int sum = 0;
      for (int i = 1; i &lt;= n; i++)
      {
         sum += Square(i);
      }
      return sum;
   }
}</code></pre>

<p>a porovnejte to s tímhle:

<pre><code class="language-fsharp">let square x = x * x
let sumOfSquares n = [1..n] |&gt; List.map square |&gt; List.sum</code></pre>

<p>To je 17 řádek ku 2. <a
href="http://www.simontylercousins.net/journal/2013/2/22/does-the-language-you-choose-make-a-difference.html">Představte
si ten rozdíl, když to rozložíte na celý projekt!</a> Kdybych takhle
přistupoval k psaní mých programů, moje produktivita by drasticky klesla.
Brrr, lepší si to ani nepředstavovat.

<h3 id="toc-duvod-treti-miluju-slozene-zavorky">Důvod třetí: Miluju složené
závorky</h3>

<p>A to taky dost nepobírám. Co je jako na těch jazycích, co se snaží
zbavit všech těch závorek? Jak je pak vůbec můžeme považovat za
opravdové programovací jazyky?

<p>Pojďme si ukázat, co mám na mysli. Tady je kus kódu se starejma dobrejma
složenejma závorkama:

<pre><code class="language-csharp">public class Squarer
{
    public int Square(int input)
    {
        var result = input * input;
        return result;
    }

    public void PrintSquare(int input)
    {
        var result = this.Square(input);
        Console.WriteLine("Input={0}. Result={1}", input, result);
    }
}</code></pre>

<p>a tady obdobný kód bez složenejch závorek:

<pre><code class="language-fsharp">type Squarer() =

    let Square input =
         let result = input * input
         result

    let PrintSquare input =
         let result = Square input
         printf "Input=%i. Result=%i" input result</code></pre>

<p>Vidíte to? Já teda nevím jak vám, ale mně ta druhá ukázka přijde dost
znepokojující, jako by tam něco důležitého chybělo. Ruku na srdce, jsem
celkem ztracený, když se mé oko nemůže odpíchnout od povědomých
složených závorek.

<h3 id="toc-duvod-ctvrty-chci-videt-explicitni-typy">Důvod čtvrtý: Chci
vidět explicitní typy</h3>

<p>Zastánci funkcionálního programování tvrdí, že odvozování typů,
dělá kód čistším, protože ho nemusíte pořád zanášet typovými
deklaracemi.

<p>Abych byl upřímný, já typové deklarace vidět chci. Necítím se ve své
kůži, když nevidím jakého typu parametr přesně je. To je také důvod,
proč mám rád Javu.

<p>Tady je signatůra funkce z nějakýho ML dialektu. Nejsou tam vůbec
žádný deklarace typů. Všechny jsou odvozený automagicky:

<pre><code class="language-fsharp">let GroupBy source keySelector =
    ...</code></pre>

<p>A tady je signatura té samé funkce v C#, s explicitně
vyjádřenými typy:

<pre><code class="language-csharp">public IEnumerable&lt;IGrouping&lt;TKey, TSource&gt;&gt; GroupBy&lt;TSource, TKey&gt;(
    IEnumerable&lt;TSource&gt; source,
    Func&lt;TSource, TKey&gt; keySelector
    )
    ...</code></pre>

<p>Já teda nevím jak vám, ale mně se víc líbí druhá ukázka. Pro mě je
velice důležité, abych viděl, že ta funkce vrací
<code>IEnumerable&lt;IGrouping&lt;TKey, TSource&gt;&gt;</code>.

<p>Tak určitě. Kompilátor jako zjistí, co je to za typ a upozorní mě,
když to nesedí, ale proč by to, proboha, měl dělat kompilátor? Od čeho
mám svůj mozek?

<p>Přiznávám, že pokud pracujete s generiky, lambda výrazy a s funkcemi,
které vracejí funkce a s dalšíma cool novinkama, tak pak asi můžou být
typové declarace trochu fousaté a komplexní. Může to být trochu těžké,
napast správný typ. Ale na druhou stranu, existuje na to jednoduchý lék:
<strong>Nepoužívejte generika a nepředávejte si funkce.</strong> Vaše
signatury budou o dost jednodušší!

<h3 id="toc-duvod-paty-rad-opravuju-bugy">Důvod pátý: Rád opravuju bugy</h3>

<p>Neznám nic napínavějšího než je lov – vystopovat a zlikvidovat
pořádnou bugu. A když najdu bugu v produkci, ještě líp, protože navíc
budu ještě za hrdinu.

<p>Četl jsem, že <a
href="http://www.simontylercousins.net/journal/2013/3/7/why-bugs-dont-like-f.html">se
staticky typovnými funkcionálními jazyky, je mnohem těžší
zanést chybu.</a>

<p>No tě pic.

<h3 id="toc-duvod-sesty-v-debuggeru-jsem-jako-doma">Důvod šestý: V debuggeru
jsem jako doma</h3>

<p>A když už jsem u toho lovení bugů. Většinu dne trávím v debuggeru,
krokováním kódu. Já vím, měl bych psát unit testy. Jenže to se
snadnějš řekne, než dělá…

<p>Každopádně, podle všeho, <a
href="http://www.haskell.org/haskellwiki/Why_Haskell_just_works">pokud se vám
ve staticky typovaném funkcionálním jazyce podaří program zkompilovat,
většinou i funguje</a>. Prej musíte většinu času zabít tím, aby jste
správně poladili typy, aby to pěkně sedělo a pak máte hotovo. Co je na tom
zábavného?

<p>Což mě přivádí k…

<h3 id="toc-duvod-sedmy-nechci-premyslet-nad-kazdym-detailem">Důvod sedmý:
Nechci přemýšlet nad každým detailem</h3>

<p>Všechno to ladění typů a ujišťování se, že všechno perfektně
sedí, zní celkem nudně.

<p>Dokonce jsem někde slyšel, že jste nucený přemýšlet o každém
možném hraničním případu, všech možných chybových stavech a já
nevím, co se ještě může zvrtnout. A to všechno od samého začátku.
Prostě nemůžeš být línej a nechat to na pozdějc.

<p>Radši se zaměřuju na to, aby (většinou) všechno prošlo tak jak má a
bugy řeším, až když se ukážou.

<h3 id="toc-duvod-osmy-rad-overuju-null">Důvod osmý: Rád ověřuju null</h3>

<p>Jsem <a
href="http://stackoverflow.com/questions/7585493/null-parameter-checking-in-c-sharp">velmi
svědomitý v případě ověřování <code>null</code> a to v každé
metodě</a>. Celkem mě uspokojuje pocit, že vím, že můj kód je ve
výsledku úplně neprůstřelný.

<pre><code class="language-csharp">void SomeMethod(SomeClass x)
{
    if (x == null) { throw new ArgumentNullException(); }

    x.DoSomething();
}</code></pre>

<p>Kecám. Samozřejmě to nedělám úplně všude, to bych vůbec nic jinýho
neudělal.

<p>Ale, nakonec se mi stalo jen jednou, že jsem musel řešit pád, kvůli
<code>NRE</code>. Ani jsme nepřišli o moc peněz za těch pár tejdnů, kdy
jsem hledal, kde je vlastně problém. Fakt nechápu, proč se z toho <a
href="http://www.infoq.com/presentations/Null-References-The-Billion-Dollar-Mistake-Tony-Hoare">dělá
taková věda</a>.

<h3 id="toc-duvod-devaty-rad-aplikuju-navrhove-vzory-kde-je-to-mozne">Důvod
devátý: Rád aplikuju návrhové vzory, kde je to možné</h3>

<p>Poprvý jsem o návrhových vzorech četl v knize <a
href="http://knihy.cpress.cz/navrhove-vzory.html">Návrhové vzory</a>
(z nějakýho důvodu se občas označuje jako GoF vzory, ale fakt netušim
proč) a od tý doby je fakt pilně aplikuju na všechny problémy. Můj kód
pak vypadá líp a má „enterprise“ nádech. A to se mému
šéfovi líbí.

<p>Ale ještě jsem ani náznakem neslyšel o nějakých vzorech ve
funkcionálním programování. Jak vůbec můžete udělat něco užitečnýho
bez <a href="http://www.algoritmy.net/article/1639/Strategy">Strategie</a>, <a
href="http://www.algoritmy.net/article/1403/Abstract-factory">Abstraktní
továrny</a>, <a
href="http://www.algoritmy.net/article/1629/Decorator">Dekorátoru</a>, <a
href="http://objekty.vse.cz/Objekty/Vzory-Proxy">Proxy</a> nebo dalších?

<p>Možná o nich funkcionální programátoři ani neslyšeli…

<h3 id="toc-duvod-desaty-je-tam-prilis-matematiky">Důvod desátý: Je tam
příliš matematiky</h3>

<p>Tady je další ukázka počítání mocnin. IMO je dost těžký pochopit,
o co vlastně jde, protože je tam sousta nesmyslných symbolů:

<pre><code class="language-j">ss=: +/ @: *:</code></pre>

<p>Dobře, omlouvám se, moje chyba, tohle je <a
href="http://en.wikipedia.org/wiki/J_(programming_language)">kód v J</a>. Ale
stejně jsem viděl, jak je ten funkcionální kód plnej různých
<code>&lt;*&gt;</code> a <code>&gt;&gt;=</code> a vůbec takových divných
konceptů jako jsou „monády“ a „funktory“.

<p>Fakt nechápu, proč tihle funkcionalisti nemohli nechat věci, který už
dobře znám – jasné symboly jako <code>++</code> nebo <code>!=</code> a
jednoduché koncepty jako je „dědičnost“ a „polymorfismus“.

<h3 id="toc-shrnuti-fakt-to-nechapu">Shrnutí: Fakt to nechápu</h3>

<p>Víte co? Fakt to nechápu. Nechápu, co by mohlo být na funkcionálním
programování užitečný.

<p>Jediný oč žádám je, aby mi někdo <a
href="http://fsharpforfunandprofit.com/why-use-fsharp/">ukázal skutečné
benefity na jedný stránce</a>, místo chrlení příliš spousty nesourodých
informací.

<p><strong>Update:</strong> Tak jsem si přečetl tu stránku „vše co
potřebujete vědět na jediné stránce.“ Ale je to <a
href="http://www.devbook.cz/jak-zacit-programovat-tvorit-aplikace-programy">příliš
krátké a zjednodušující</a>, aby mi to dávlo smysl. Fakt hledám něco, co
<a
href="http://programujte.com/clanek/2006032503-co-je-to-funkcionalni-programovani/">má
trochu hloubku</a>, něco, co by mě <a
href="http://www.knesl.com/articles/view/jak-se-pustit-do-ukolu-ktery-se-vam-nechce-delat">fakt
chytlo</a>.

<p>A ne, fakt nemám chuť <a href="http://learnyouahaskell.com/">číst
tutoriály</a>, <a href="http://www.tryfsharp.org/Learn">hrát si
s ukázkama</a> a psát vlastní kód. Chci tomu jen přijít na kloub, bez
toho, abych musel dělat všechny ty zbytečný věci.

<p><strong>Nechci měnit to, jak myslím, jen se chci naučit to nové
paradigma.</strong>

<p><em>článek je volným překladem <a
href="http://fsharpforfunandprofit.com/posts/ten-reasons-not-to-use-a-functional-programming-language/">Ten
reasons not to use a statically typed functional programming language</a> od
Scotta Wlaschina</em>

<!-- by Texy2! -->
</div>
<footer class=vcard>
Autor: <strong class="user fn">Aleš Roubíček</strong> |
<a href="http://www.rarous.net/weblog/448-deset-duvodu-proc-nepouzivat-funkcionalni-jazyky.aspx#komentare">13x komentováno</a>
</footer>
</article>

<article class="hentry" id="article-447">
<header>
<h2 class="entry-title"><a href="http://www.rarous.net/weblog/447-zatocime-s-null.aspx" title="Zatočíme s null" rel="Bookmark">Zatočíme s null</a></h2>
<p class="info">
<span class="published">13.29 - 11. dubna 2013<span class="value" title="2013-04-11T13:29:00Z"></span></span> |
<strong>Moje práce</strong>
</header>
<div class="entry-content">

<p>Chtěl bych se v takové kratké sérii blogů dostat k jednotlivým bodům
<a href="/weblog/444-manifest-nejen-objektove-orientovaneho-vyvoje.aspx">NOOO
manifesta a jeho principům</a>. V této sérii, bych chtěl vyjádřit, proč
se k tomuto manifestu hlásím, a i ukázat pár praktických důsledků
v hodnotách a principech obsažených.

<p>Dnes se zastavíme u toho, proč preferuji <strong>Option</strong> před
<em>null</em> a proč:

<blockquote>
	<p>Upřednostňujeme reprezentaci invariant na úrovni typů před reprezentací
	na úrovni hodnot.
</blockquote>

<h3 id="toc-problematika-null">Problematika null</h3>

<p>Snad každý, kdo se zabývá programováním narazil na problém s
<code>null</code> hodnotami. Většinou se projevuje tak, že z ničeho nic
dostaneme někde <code>NullReferenceException</code> (NRE) a máme po ptákách.
Tento problém je celkem častý a <a
href="http://blogs.msdn.com/b/dsyme/archive/2013/03/25/quote-of-the-week-quot-what-can-c-do-that-f-cannot-quot.aspx">odhaduje
se, že každý rok má za následek ztrátu $1B</a>. To je pro představu
1 000 000 000 USD. Ztráta je způsobena jak samotným projevem, tak
i náklady vynaloženými na obranu před <code>NRE</code>.

<h3 id="toc-obrana">Obrana</h3>

<p>Jistě znáte techniky defenzivního programování, jako jsou <em>Code
Contracts</em> v jejich různých mutacích, které efektivně zvyšují
náklady na tvorbu a správu přebujelé code base, v který aby se čert
vyznal. Další se snaží o zavedení nového syntaktického prvku, který
vypadá následovně: <code>foo?bar()</code> a dělá to samé co <code>if (foo
!= null) foo.bar();</code>. Pořád jen to jen maskování symptomů. Ne
řešení problému.

<h3 id="toc-prevence">Prevence</h3>

<p>Další možností je používat jazyky, jako je třeba F#, které
<code>null</code> nemají. (Ok, F# zná <code>null</code>, ale musíte si
explicitně o něj říct a označit tak potenciálně nebezpečný kód, jinak
by asi moc nemohl pracovat s již existujícími .net knihovnami.) Většinou
se jedná o funkcionální jazyky se sofistikovanými typovými systémy.

<p>Nechme se inspirovat některými dobrými vzory:

<h3 id="toc-null-object">Null Object</h3>

<p>Pokud děláte TDD, nebo se zajímáte o návrhové vzory, jistě už jste
na tento vzor narazili. Jde o to, že ve vašem systému máte definované
„implementační“ třídy, které nemají žádnou implementaci, nebo
prostě jen nikdy nevyhazují výjimky. Slouží pouze k tomu, že pokud
systému nenabídneme nějakou jinou funkční implementaci, nemusíme se
obávat <code>NRE</code>, protože tu máme bezpečný <em>Null Object</em>.

<p>Já ho třeba používám vždycky, když implementuji logování:

<pre><code class="language-csharp">ILogger logger = NullLogger.Instance;
public ILogger Log {
  get { return logger; }
  set { logger = value ?? NullLogger.Instance; }
}</code></pre>

<p>Po inicializaci je logger nastaven na instanci <code>NullLogger</code>u.
Logger je možné injektovat, ale pokud se někdo pokusí podstrčit
<code>null</code>, tak si podržíme <code>NullLogger</code>. Za předpokladu,
že se <code>logger</code> nepoužívá nikde jinde, než v property, máme
bezpečno a nemusíme psát spoustu defenzivního kódu jako:

<pre><code class="language-csharp">if (Log != null) Log.Info("foo");</code></pre>

<p>Samozřejmě to není jediný případ užití. Další, z možných
implementací, je vyjádření speciálního stavu, jako třeba:

<pre><code class="language-csharp">public class AsyncResult {
  public AsyncResult(XElement response) {
    Response = response;
  }
  public XElement Response { get; set; }
}

public class QueryInProgress : AsyncResult {
  public QueryInProgress() : base(null) { }
}</code></pre>

<p>Tohle je <em>Null Object</em> implementovaný v SOA. Systém dostane ke
zpracování nějaký požadavek (dotaz) a když se následně zeptá na
výsledek, dostane buď Null Object <code>QueryInProgress</code>, který
říká, že dotaz se ještě zpracovává, nebo už samostatnou odpověď.
<strong>Null Object může mít i sémantický význam.</strong>

<h3 id="toc-option">Option</h3>

<p>Jazyky, které podporují pattern-matching, umožňuji práci s typem
Option:

<pre><code class="language-fsharp">let exists (x : int option) =
    match x with
    | Some(x) -&gt; true
    | None -&gt; false</code></pre>

<p><code>None</code> nám nahrazuje <code>null</code>, ale nejedná se
o hodnotu, ale o typ. Typ <code>Option</code> je totiž definován jako
generické disjunktivní sjednocení:

<pre><code class="language-fsharp">type Option&lt;'T&gt; =
  | None
  | Some of 'T</code></pre>

<p>Na rozdíl od vzoru <code>Null Object</code> tu neztrácíme nutnost
rozhodování se, jak se v případě <code>None</code> zachovat. Nadruhou
stranu, máme speciální případ explicitně sémanticky vyjádřen na
úrovni typu.

<h3 id="toc-maybe">Maybe</h3>

<p><code>Maybe</code> je v případě užití celkem podobný
<code>Option</code> s tím rozdílem, že jde o monad. Krom toho, že je opět
parametricky polymorfní (generický), splňuje i požadavky na monadičnost.
Monadičnost nám <em>umožňuje kompozici</em> a můžeme i využít
vlastostí jazyka jako je LINQ, který je postavený nad sekvenčním monadem,
ale nic nám nebrání ho použít i nad jinými. Třeba právě
nad maybe.

<p>Nepotřebujeme však nutně Haskell, abychom mohli využívat všech výhod.
Tohle je třeba C#:

<pre><code class="language-csharp">return TryGetCachedData(message, metadata, request).Match(
  some: data =&gt; CachedResult(message.RequestId, data, stats),
  none: () =&gt; Result(message, context, metadata, request, stats));</code></pre>

<p>Implementaci <code>Maybe</code> monadu z ukázky najdete <a
href="https://gist.github.com/rarous/5355792">v tomto gistu</a>.

<h3 id="toc-zaver">Závěr</h3>

<p>Null je zlo. Je možné s ním bojovat silou nebo inteligencí. Já byl
vždycky slabý a líný, proto preferuji výše zmíněné <em>možnosti</em>
prevence před samotnou obranou. Náš projekt sice není úplně imuní vůči
<code>null</code>, ale díky <em>Null Objectu</em> a <em>Maybe monadu</em>,
které se dají krásně kombinovat, je kód čistší a méně náchylný
k chybám. Snad. :)

<!-- by Texy2! -->
</div>
<footer class=vcard>
Autor: <strong class="user fn">Aleš Roubíček</strong> |
<a href="http://www.rarous.net/weblog/447-zatocime-s-null.aspx#komentare">4x komentováno</a>
</footer>
</article>

<article class="hentry" id="article-446">
<header>
<h2 class="entry-title"><a href="http://www.rarous.net/weblog/446-kratka-pohadka-o-zlobivych-bytech-v-db.aspx" title="Krátká pohádka o zlobivých bytech v DB" rel="Bookmark">Krátká pohádka o zlobivých bytech v DB</a></h2>
<p class="info">
<span class="published">20.19 - 3. dubna 2013<span class="value" title="2013-04-03T20:19:58Z"></span></span> |
<strong>Moje práce</strong>
</header>
<div class="entry-content">

<p>„Celý je to pomalý a taví nám to databázi. Vždyť tam máme pár
uživatelů a už to nezvládá. To jste se vyznamenali, borci.“ A to byl
začátek celkem slušného redesignu, dva měsíce po spuštění do produkce,
s celkem zajímavě naplněnou databází. Po létě proseděným ve stínu
kolbenky, značném vyčerpání z posunování vostrýho startu. Krásná vize
na barevný podzim a začátek zimy.

<p>A za celým tím byla úžasná myšlenka <strong>ukládat obrázky do
databáze</strong>. Vždyť MS SQL to umí, dokonce má datový typ
<code>FileStream</code>, který ukládá soubory „fyzicky“ na file systém!
Jistoty, prosperita. Samý profit. Vzpomínáte na Longhorn a jeho geniální
WinFS, která měla spasit správu souborů?

<h3 id="toc-o-necely-rok-drive">O necelý rok dříve</h3>

<p>Když jsem s novým rokem nastupoval do nového zaměstnání, projekt už
pár měsíců běžel. Při procházení datové vrstvy mě zarazila jedna věc
a to, že se obrázky ukládaly přímo do databáze. Entity, které měly
navázané obrázky prostě obsahovaly vlastnost typu <code>byte[]</code>.
Puristický dogmatik ve mně zpozorněl. „Přijde vám ukládat nerelační
data do relační databáze ok? Mně teda ne.“ Říkám pánům architektům.
Neviděli na tom nic špatného a jelo se dál.

<p>Za pár měsíců se rozhodlo, že budeme hostovat v cloudu. SQL Azure sice
<code>FileStream</code>y neumí, ale pořád můžeme mít
<code>varbinary</code> sloupce. Mně se to furt nezdálo. Je to „good
enough,“ jak se s oblibou říkalo.

<p>Problem solved.

<!-- by Texy2! -->
</div>
<footer class=vcard>
Autor: <strong class="user fn">Aleš Roubíček</strong> |
<a href="http://www.rarous.net/weblog/446-kratka-pohadka-o-zlobivych-bytech-v-db.aspx#komentare">6x komentováno</a>
</footer>
</article>

<article class="hentry" id="article-445">
<header>
<h2 class="entry-title"><a href="http://www.rarous.net/weblog/445-asynchronni-vs-paralelni-zpracovani-uloh.aspx" title="Asynchronní vs. paralelní zpracování úloh" rel="Bookmark">Asynchronní vs. paralelní zpracování úloh</a></h2>
<p class="info">
<span class="published">12.42 - 26. března 2013<span class="value" title="2013-03-26T12:42:52Z"></span></span> |
<strong>Moje práce</strong>
</header>
<div class="entry-content">

<p>S příchodem <code>async/await</code> do C# 5.0 se nám v různých APIs
objevily asynchronní metody, které vracejí <code>Task</code> nebo
<code>Task&lt;T&gt;</code> a jejich název je vybaven kouzelným postfixem
<code>Async</code>. Jde o takzvaný <a
href="http://msdn.microsoft.com/en-us/library/hh873175.aspx">Task-based
Asynchronous Pattern (TAP)</a>. A protože je postavený na datové struktuře
<code>Task</code> může svádět k vlastním implementacím, které nejsou tak
říkajíc <em>zrovna optimální</em>.

<blockquote class="twitter-tweet">
	<p>That's an <a href="https://twitter.com/search/%23async">#async</a>
	implementation! Not! <a href="http://t.co/sHBSxhfthj"
	title="http://ow.ly/jjzrf">ow.ly/jjzrf</a> <a
	href="https://twitter.com/search/%23sqlite">#sqlite</a>
	— Jiri Cincura (@cincura_net) <a
	href="https://twitter.com/cincura_net/status/315067029021413376">March 22,
	2013</a></blockquote>

<p>Začneme malou ukázkou z praxe. V předchozím tweetu Jirka ukazuje na
„asynchronní“ implementaci metody <code>ToFirstAsync()</code> ze
SQLite:

<pre><code class="language-csharp">public Task&lt;T&gt; ToFirstAsync ()
{
  return Task&lt;T&gt;.Factory.StartNew(() =&gt; {
    using (((SQLiteConnectionWithLock)_innerQuery.Connection).Lock ()) {
      return _innerQuery.ToFirst ();
    }
  });
}</code></pre>

<p>Co je na ní špatného?

<p>Když pominu maďarské podtržítko, mezery před závorkama, zbytečné
složené závorky a vůbec… Zkrátka vidíme ukázkový pokus o implementaci
TAP pomocí <a href="http://msdn.microsoft.com/en-us/library/dd460717.aspx">Task
Parallel Library (TPL)</a>. A to je <strong>špatně</strong>. Ve skutečnosti
nejde o asynchronní operaci, ale o operaci odpálenou na jiném threadu.

<h3 id="toc-asynchronni-vs-paralelni">Asynchronní vs. paralelní</h3>

<p>Nejprve bychom si asi měli ujasnit, jaký rozdíl je mezi asynchronním a
paralelním zpracováním, protože to stále většině lidí není jasné.
Ano, i já se v tom občas ztrácím, ale snažím se. :)

<p>Představte si dlouhotrvajících operaci. Řekněme takovou, která není
přímo spojená s výpočtem (CPU-bounded), ale takovou, která si šahá na
některé ze vstupně/výstupních zařízení (IO-bounded). Tak tedy vězte,
že asynchronní operace je taková, která běží v tomto zařízení. Pokud
třeba čteme z disku, databáze nebo z cloudu, pošleme požadavek na
zařízení a <strong>nečekáme na odpověď</strong> přímo, ale necháme
zařízení <strong>ať se nám ozve samo</strong>, až bude jeho odpověď
připravená. Mezi tím se může aplikace věnovat jiným úlohám. Žádná
vlákna zde není třeba zmiňovat.

<p>Pokud zadáme úlohu ke zpracování jinému vláknu, zavádíme konkurenci.
Ukázka výše odstartuje nový Task, který se s největší
pravděpodobností spustí na jiném threadu a záhy ho zamkne. Sice neblokuje
vlákno, ze kterého operaci voláme, ale blokujeme vlákno jiné. Jaký je
účel? A náklady na synchronizaci?

<p>Paralelizace je vhodná tam, kde máme <strong>výpočetně náročné
operace</strong> a dají se rozdělit na několik kroků, které mohou běžet
konkurenčně. Tj. nesdílí stav a slouží třeba jako mezivýsledky
v nějakém větším výpočtu. Typickým příkladem může být Map/Reduce.
Mapování může běžet paralelně, redukce pak proběhne po doběhnutí
mapování, případně může také probíhat paralelně v nějakých
clusterech dat.

<p>Tak, snad je to už jasné. :)

<p>Dalším velkým rozdílem je, že paralelizace zpracování je
implementační detail, a ten by jako takový neměl prosakovat do APIs. Pokud
tedy uvidíte metodu, která vrací <code>Task</code> nebo
<code>Task&lt;T&gt;</code> a v její implementaci je <code>Task.Run</code>
potažmo starší verze <code>Task.Factory.StartNew</code>, považujte to
za smell.

<h3 id="toc-taky-jsem-ji-mel">Taky jsem ji měl</h3>

<p>Popravdě, taky jsem takovou metodu měl. Zjednodušeně vypadala asi
nějak tak:

<pre><code class="language-csharp">class Client : ConsumerOf&lt;Message&gt; {
  readonly ManualResetEvent sync = new ManualResetEvent(false);

  public Task&lt;Result&gt; QueryAsync(Request request) {
    return Task.Factory.StartNew(() =&gt; {
      SendQuery(request.ToQuery());
      sync.Wait();
      return Result;
    });
  }

  public void Consume(Message msg) {
    sync.Set();
    Result = msg.ToResult();
  }
}</code></pre>

<p>Jak vidíte, spouští se tu nový Task, který odešle dotaz a čeká na
odpověď. Dotaz i odpověď jsou zprávy cestující po service busu.
Všimněte si <em>synchronizace</em> (sic!) pomocí signální události.
Navenek se to tváří jako asynchronní, ale je to celkem pěkně drahá
sranda. Jak to udělat opravdu asynchronně?

<h3 id="toc-lepsi-reseni">Lepší řešení</h3>

<p>Klíčem k úspěchu je využití třídy
<code>TaskCompletionSource</code>:

<pre><code class="language-csharp">class Client : ConsumerOf&lt;Message&gt; {
  readonly TaskCompletionSource tcs = new TaskCompletionSource();

  public Task&lt;Result&gt; QueryAsync(Request request) {
    SendQuery(request.ToQuery());
    return tcs.Task;
  }

  public void Consume(Message msg) {
    tcs.TrySetResult(msg.ToResult());
  }
}</code></pre>

<p>Task nevytváříme pomocí <code>TaskScheduler</code>u, který ho alokuje
někde na ThreadPoolu, ale pomocí <code>TaskCompletionSource</code>. Result se
nastaví ve chvíli, kdy přijde odpověď. Nepotřebujeme žádné semafory,
vše funguje pěkně asynchronně. Můžeme snadno přidat řešení chybových
stavů, timeout nebo cancellation. Dle potřeb a celkem levně.

<h3 id="toc-zaver">Závěr</h3>

<p>Asynchronní APIs má cenu vystavovat pouze u IO operací. Výpočetně
náročné operace můžeme vnitřně paralelizovat, ale nikdy tento detail
nezveřejňujeme v APIs. Pro asynchronní operace nepoužíváme
<code>TaskFactory</code> ani synchronizační objekty, ale
<code>TaskCompletionSource</code>. Já už si to budu pamatovat. Doufám, že
i vy. :)

<!-- by Texy2! -->
</div>
<footer class=vcard>
Autor: <strong class="user fn">Aleš Roubíček</strong> |
<a href="http://www.rarous.net/weblog/445-asynchronni-vs-paralelni-zpracovani-uloh.aspx#komentare">14x komentováno</a>
</footer>
</article>

<article class="hentry" id="article-444">
<header>
<h2 class="entry-title"><a href="http://www.rarous.net/weblog/444-manifest-nejen-objektove-orientovaneho-vyvoje.aspx" title="Manifest Nejen Objektově Orientovaného Vývoje" rel="Bookmark">Manifest Nejen Objektově Orientovaného Vývoje</a></h2>
<p class="info">
<span class="published">14.01 - 25. března 2013<span class="value" title="2013-03-25T14:01:23Z"></span></span> |
<strong>Moje práce</strong>
</header>
<div class="entry-content">

<p>Narazil jsem na velmi zajímavý <a href="http://notonlyoo.org/">manifest
Nejen objektově orientovaného vývoje</a> a myslím, že by neměl ujít
pozornosti ani tady v československu.

<h3 id="toc-preklad-manifestu">Překlad Manifestu</h3>

<p>Objevujeme lepší způsoby vývoje software tím, že jej tvoříme a
pomáháme při jeho tvorbě ostatním. Při této práci jsme dospěli
k těmto hodnotám:

<ul>
	<li><strong>Funkce a typy</strong> před třídami

	<li><strong>Čistota</strong> před mutacemi

	<li><strong>Kompozice</strong> před dědičností

	<li><strong>Funkce vyššího řádu</strong> před <em>method
	dispatch</em>

	<li><strong>Option</strong> před <code>null</code>
</ul>

<p>Tak jest, přestože je v bodech napravo hodnota (kromě <code>null</code>),
bodů nalevo si ceníme více.

<h3 id="toc-principy">Principy</h3>

<p>Ctíme následující principy:

<ul>
	<li>Učení se vícero paradigmat nám umožňuje lepší řešení
	problémů.

	<li>Používáme nejvhodnější paradigmata pro daný problém, nejen ta,
	která aktuálně ovládáme.

	<li>Upřednostňujeme přemýšlení nad nejlepším řešením problému před
	slepým následováním <em>best practice</em>, směrnic, vzorů a
	frameworků.

	<li>Upřednostňujeme reprezentaci invariant na úrovni typů před
	reprezentací na úrovni hodnot.
</ul>

<!-- by Texy2! -->
</div>
<footer class=vcard>
Autor: <strong class="user fn">Aleš Roubíček</strong> |
<a class="rss" href="http://www.rarous.net/weblog/444-manifest-nejen-objektove-orientovaneho-vyvoje.aspx#komentare">2x komentováno</a>
</footer>
</article>

</div>

<div class="footer">

<div class="box drop rubriky">
<h2>Rubriky</h2>
<div class="inner">
<ul><li><a href="/weblog/skola.aspx" title="Vypsat články z rubriky Škola.">Škola</a>
    <li><a href="/weblog/webdesign.aspx" title="Vypsat články z rubriky Webdesign.">Webdesign</a>
    <li><a href="/weblog/jen-tak.aspx" title="Vypsat články z rubriky Jen tak.">Jen tak</a>
    <li><a href="/weblog/moje-prace.aspx" title="Vypsat články z rubriky Moje práce.">Moje pr&#225;ce</a>
    <li><a href="/weblog/kamaradi.aspx" title="Vypsat články z rubriky Kamarádi.">Kamar&#225;di</a>
    <li><a href="/weblog/muzika.aspx" title="Vypsat články z rubriky Muzika.">Muzika</a>
    <li><a href="/weblog/tuning.aspx" title="Vypsat články z rubriky Tuning.">Tuning</a>
    <li><a href="/weblog/gryphoon.aspx" title="Vypsat články z rubriky Gryphoon.">Gryphoon</a>
    <li><a href="/weblog/asp-net-2-0.aspx" title="Vypsat články z rubriky ASP.NET 2.0.">ASP.NET 2.0</a>
    <li><a href="/weblog/webove-sluzby.aspx" title="Vypsat články z rubriky Webové služby.">Webov&#233; služby</a>
    </ul>
</div>
</div>

    <div class="ads">
        <p>© 2014 Aleš Roubíček. Publikováno pod licencí <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/">Creative Commons 4.0 Attribution-ShareAlike</a>.</p>
    </div>
</div>

</div>
<script src="//platform.twitter.com/widgets.js" charset="utf-8"></script>
<script src="/assets/js/prism.js"></script>

